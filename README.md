# push_swap 設計書（草案）

## 1. 概要

本プログラム `push_swap` は、スタック`a`に与えられたランダムな整数を、スタック`b`と規定の基本操作のみを使用して、可能な限り少ない手数で昇順にソートすることを目的とする。

## 2. 設計方針

評価基準である「操作回数の最小化」を達成するため、以下の 3 つの技術を組み合わせたハイブリッド戦略を採用する。

- **データ構造**: **双方向循環リスト**
  - `ra`, `rra`のような回転操作を効率的(`O(1)`)に行うために採用する。
- **データ前処理**: **座標圧縮**
  - 入力値の絶対的な大きさではなく、相対的な順位（ランク）でソート戦略を扱うことで、アルゴリズムを単純化・効率化する。
- **ソートアルゴリズム**: **チャンク分割 + 少数ケース最適化**
  - 要素数が多い場合：ランクに基づいた**チャンク分割**により、体系的かつ効率的に要素をスタック`b`へ移動させる。
  - 要素数が少ない場合（例: 5 以下）：あらかじめ用意された**最短手数のアルゴリズム**で対応し、操作回数を最適化する。

## 3. アーキテクチャ（モジュール分割）

プログラムを以下の責務を持つモジュールに分割し、開発と保守を容易にする。

- **`main.c` (司令塔)**
  - プログラム全体の流れを制御し、各モジュールを適切な順序で呼び出す。
- **`validate_and_parse.c` (入力検証/解析)**
  - コマンドライン引数の検証（形式・範囲・重複）と、後続処理で利用する一時的な構造体配列の生成を担う。
- **`utils_atoll.c` (数値変換)**
  - `ft_atoll`を実装。文字列を`long long`へ安全に変換するツール。
- **`utils_checks.c` (検証ヘルパー)**
  - `has_duplicates`など、`validate_and_parse.c`から呼び出される個別の検証ロジック。
- **`coordinate_compression.c` (座標圧縮)**
  - 検証済みの数値にランクを割り振る。
- **`list_utils.c` (データ構造)**
  - 双方向循環リストの基本的な操作（ノード作成、追加、削除など）を担う。
- **`operations.c` (基本操作)**
  - `sa`, `pb`, `ra`など 11 種類の基本操作を実装し、命令を標準出力する。
- **`solver.c` (ソート戦略)**
  - プロジェクトの頭脳。要素数に応じて少数ケースのロジックとチャンク分割ロジックを振り分け、実行する。

## 4. データ構造

本プロジェクトでは、2 種類の主要なデータ構造を用いる。

1.  **`t_number_info` (一時的な構造体)**: 入力検証と座標圧縮フェーズで使用する。
    ```c
    typedef struct s_number_info
    {
        int value; // 検証済みの元の数値
        int rank;  // 座標圧縮後の順位
    }   t_number_info;
    ```
2.  **`t_stack_node` (スタックのノード)**: 双方向循環リストの各要素。
    ```c
    typedef struct s_stack_node
    {
        int                 value;
        int                 rank;
        struct s_stack_node *next;
        struct s_stack_node *prev;
    }   t_stack_node;
    ```

## 5. 実装フロー

以下のフェーズとステップに従って実装を進める。

### フェーズ 1：入力検証とデータ準備

1.  **`main`**: 引数の数 (`argc`) をチェック。`validate_and_parse_args`を呼び出す。
2.  **`validate_and_parse_args`**:
    a. `t_number_info`型の配列を`malloc`で確保する。
    b. `argv`をループし、各引数に対して以下を実行：
    i. `ft_atoll`を呼び出し、`long long`に変換（形式/`long long`範囲エラーを検知）。
    ii. `int`の範囲内にあるかチェック。
    iii. 問題なければ、`.value`を構造体配列に格納。
    c. ループ後、構造体配列の`.value`フィールドを対象に**重複チェック**を行う。
    d. エラーがあれば確保したメモリを解放し、失敗を`main`に返す。成功すれば、構造体配列のアドレスを`main`に渡す。
3.  **`main`**: `validate_and_parse_args`が成功したら、**座標圧縮**を行う関数を呼び出す。この関数は`t_number_info`配列を受け取り、各要素の`.rank`フィールドを埋める。
4.  **`main`**: `value`と`rank`が揃った`t_number_info`配列を元に、スタック`a`（双方向循環リスト）を構築する。

### フェーズ 2：ソート実行

5.  **`main`**: `solver`関数を呼び出す。
6.  **`solver`**:
    a. スタック`a`のサイズを確認。
    b. **もしサイズが 5 以下なら**: 少数ケース用の最適化ロジックを実行する。
    c. **もしサイズが 6 以上なら**: チャンク分割アルゴリズムを実行する。
    i. **A→B**: チャンクの数を決定し、ランクの範囲に基づいてスタック`a`から`b`へ要素を移動させる。最適な回転（`ra` vs `rra`）を計算しながら行う。
    ii. **B→A**: スタック`b`内の最大ランクの要素を探し、最適な回転（`rb` vs `rrb`）で`b`のトップに移動させてから`pa`で`a`に戻す。これを`b`が空になるまで繰り返す。

### フェーズ 3：終了処理

7.  **`main`**: `malloc`で確保した全てのメモリ（構造体配列、スタックのノード）を解放する。

## 6. エラーハンドリング

以下の全てのケースで、標準エラー出力に`"Error\n"`と表示し、プログラムを終了させる。

- **形式エラー**:
  - 数字以外の文字が含まれる。
  - 不正な符号（例: `++1`, `1-2`）。
  - 空文字列 `""`。
  - 符号のみ `"-"`, `"+"`.
- **範囲エラー**:
  - `INT_MAX`を超える、または`INT_MIN`を下回る。
- **重複エラー**:
  - 同じ数値が複数存在する。

## 7. Makefile 要件

- 最終的な実行ファイル名は`push_swap`。
- `all`, `clean`, `fclean`, `re` の標準ルールを実装する。
- `bonus` ターゲット（`checker`用）も必要に応じて実装する。
- `libft` や自作 `printf` ライブラリとの連携を考慮する。
